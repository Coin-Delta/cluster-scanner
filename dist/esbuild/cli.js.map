{
  "version": 3,
  "sources": ["../../src/cli-shared.ts", "../../src/commands/SSVScannerCommand.ts", "../../src/lib/web3.provider.ts", "../../src/cli.ts"],
  "sourcesContent": ["import figlet from 'figlet';\nimport pkg from '../package.json';\nimport { ArgumentParser } from 'argparse';\n\nimport { SSVScannerCommand } from './commands/SSVScannerCommand';\n\nconst FigletMessage = async (message: string) => {\n  return new Promise(resolve => {\n    figlet(message, (error: any, output?: string) => {\n      if (error) {\n        return resolve('');\n      }\n      resolve(output);\n    });\n  })\n}\n\nexport default async function main(): Promise<any> {\n  const parser = new ArgumentParser();\n\n  parser.add_argument('-n', '--node-url', {\n    help: `The ETH1 node url.`,\n    required: true,\n    dest: 'nodeUrl'\n  });\n  parser.add_argument('-ca', '--ssv-contract-address', {\n    help:\n      'The SSV Contract address, used to find the latest cluster data snapshot. ' +\n      'Refer to https://docs.ssv.network/developers/smart-contracts',\n    required: true,\n    dest: 'contractAddress'\n  });\n  parser.add_argument('-oa', '--owner-address', {\n    help: \"The owner address regarding the cluster that you want to query\",\n    required: true,\n    dest: 'ownerAddress'\n  });\n  parser.add_argument('-oids', '--operator-ids', {\n    help: `Comma-separated list of operators IDs regarding the cluster that you want to query`,\n    required: true,\n    dest: 'operatorIds'\n  });\n\n  \n  const messageText = `SSV Scanner v${pkg.version}`;\n  const message = await FigletMessage(messageText);\n  if (message) {\n    console.log(' -----------------------------------------------------------------------------------');\n    console.log(`${message || messageText}`);\n    console.log(' -----------------------------------------------------------------------------------');\n    for (const str of String(pkg.description).match(/.{1,75}/g) || []) {\n      console.log(` ${str}`);\n    }\n    console.log(' -----------------------------------------------------------------------------------\\n');\n  }\n\n  try {\n    let params = parser.parse_args();\n    params.operatorIds = params.operatorIds.split(',')\n      .map((value: any) => {\n        if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n        return +value;\n      });\n\n    const command = new SSVScannerCommand(params);\n    const result = await command.execute();\n    console.table(result.payload);\n    console.log('\\CLuster snapshot:');\n    console.table(result.cluster);\n  } catch (e: any) {\n    console.error('\\x1b[31m', e.message);\n  }\n}\n", "import cliProgress from 'cli-progress';\nimport Web3Provider from '../lib/web3.provider';\n\nexport interface SSVScannerParams {\n  nodeUrl: string,\n  ownerAddress: string,\n  contractAddress: string,\n  operatorIds: number[],\n}\n\nexport interface IData {\n  payload: any;\n  cluster: any;\n}\n\nexport class SSVScannerCommand {\n  protected DAY = 5400;\n  protected WEEK = this.DAY * 7;\n  protected MONTH = this.DAY * 30;\n  protected progressBar: any;\n\n  protected eventsList = [\n    'ClusterDeposited',\n    'ClusterWithdrawn',\n    'ValidatorRemoved',\n    'ValidatorAdded',\n    'ClusterLiquidated',\n    'ClusterReactivated',\n  ]\n\n  private params: SSVScannerParams;\n\n  constructor(params_: SSVScannerParams) {\n    if (!params_.contractAddress) throw Error('Contract address is required');\n    if (!params_.nodeUrl) throw Error('ETH1 node is required');\n    if (!Array.isArray(params_.operatorIds) || !this.isValidOperatorIds(params_.operatorIds.length)) throw Error('Operator ids list is not valid');\n    if (!params_.ownerAddress) throw Error('Cluster owner address is required');\n    this.params = params_;\n  }\n\n  async scan(): Promise<IData> {\n    return this.getClusterSnapshot(false);\n  }\n\n  async execute(): Promise<IData> {\n    console.log('\\nScanning blockchain...');\n    this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);\n    const data: IData = await this.getClusterSnapshot(true);\n    this.progressBar.stop();\n    return data;\n  }\n\n  async getClusterSnapshot(cli: boolean): Promise<IData> {\n    let latestBlockNumber = await Web3Provider.web3(this.params.nodeUrl).eth.getBlockNumber();\n    let step = this.MONTH;\n    let clusterSnapshot;\n    let biggestBlockNumber = 0;\n\n    const filters = {\n      fromBlock: latestBlockNumber - step,\n      toBlock: latestBlockNumber,\n      filter: {\n        owner: this.params.ownerAddress,\n      }\n    };\n\n    cli && this.progressBar.start(latestBlockNumber, 0);\n    while (!clusterSnapshot && filters.fromBlock > 0) {\n      let result: any;\n      try {\n        result = await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).getPastEvents('allEvents', filters);\n        result\n        .filter((item: any) => this.eventsList.includes(item.event))\n        .filter((item: any) => JSON.stringify(item.returnValues.operatorIds.map((value: any) => +value)) === JSON.stringify(this.params.operatorIds))\n        .forEach((item: any) => {\n          if (item.blockNumber > biggestBlockNumber) {\n            biggestBlockNumber = item.blockNumber;\n            clusterSnapshot = item.returnValues.cluster;\n          }\n        });\n        filters.toBlock = filters.fromBlock;\n      } catch(e) {\n        console.error(e);\n        if (step === this.MONTH) {\n          step = this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n        }\n      }\n      filters.fromBlock = filters.toBlock - step;  \n      cli && this.progressBar.update(latestBlockNumber - (filters.toBlock - step));  \n    }\n\n    clusterSnapshot = clusterSnapshot || ['0','0','0','0','0',false];\n    return {\n      payload: {\n        'Owner': this.params.ownerAddress,\n        'Operators': this.params.operatorIds.join(','),\n        'Block': biggestBlockNumber || latestBlockNumber,\n        'Data': clusterSnapshot.join(','),  \n      },\n      cluster: {\n        validatorCount: clusterSnapshot[0],\n        networkFee: clusterSnapshot[1],\n        networkFeeIndex: clusterSnapshot[2],\n        index: clusterSnapshot[3],\n        balance: clusterSnapshot[4],\n        disabled: clusterSnapshot[5],\n      }\n    };\n  }\n\n  private isValidOperatorIds(operatorsLength: number) {\n    return (operatorsLength < 4 || operatorsLength > 13 || operatorsLength % 3 != 1) ? false : true;\n  }\n}\n", "import Web3 from 'web3';\nimport ABI_V3 from '../shared/v3.abi.json';\n\nexport default class Web3Provider {\n  static BLOCK_RANGE_500K = 500000;\n\n  static web3(nodeUrl: string) {\n    return new Web3(nodeUrl);\n  }\n\n  static get abi() {\n    return ABI_V3 as any;\n  }\n\n  static contract(nodeUrl: string, contractAddress: string) {\n    return new (Web3Provider.web3(nodeUrl)).eth.Contract(\n      Web3Provider.abi,\n      contractAddress,\n    );\n  }\n\n  /*\n  static async currentBlockNumber(): Promise<number> {\n    return await Web3Provider.web3.eth.getBlockNumber();\n  }\n\n  static async liquidationThresholdPeriod(): Promise<number> {\n    return Web3Provider.contract.methods.getLiquidationThresholdPeriod().call();\n  }\n\n  static async minimumBlocksBeforeLiquidation(): Promise<number> {\n    return Web3Provider.contract.methods.getLiquidationThresholdPeriod().call();\n  }\n\n  static async liquidatable(ownerAddress): Promise<boolean> {\n    return Web3Provider.contract.methods.isLiquidatable(ownerAddress).call();\n  }\n\n  static async isLiquidated(ownerAddress): Promise<boolean> {\n    return Web3Provider.contract.methods\n      .isOwnerValidatorsDisabled(ownerAddress)\n      .call();\n  }\n\n  static async burnRate(ownerAddress): Promise<string> {\n    return Web3Provider.contract.methods\n      .getAddressBurnRate(ownerAddress)\n      .call();\n  }\n\n  static async totalBalanceOf(ownerAddress): Promise<string> {\n    return Web3Provider.contract.methods.getAddressBalance(ownerAddress).call();\n  }\n  */\n}\n", "#!/usr/bin/env node\n'use strict';\nimport main from './cli-shared';\n\nvoid main();\n"],
  "mappings": "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",
  "names": ["import_figlet", "import_argparse", "import_cli_progress", "import_web3", "_Web3Provider", "nodeUrl", "Web3", "v3_abi_default", "contractAddress", "Web3Provider", "SSVScannerCommand", "params_", "__async", "cliProgress", "data", "cli", "latestBlockNumber", "Web3Provider", "step", "clusterSnapshot", "biggestBlockNumber", "filters", "result", "item", "value", "e", "operatorsLength", "FigletMessage", "message", "__async", "resolve", "figlet", "error", "output", "main", "parser", "messageText", "package_default", "str", "params", "value", "result", "SSVScannerCommand", "e", "main"]
}
