{
  "version": 3,
  "sources": ["../../src/cli-shared.ts", "../../src/commands/SSVScannerCommand.ts", "../../src/lib/web3.provider.ts", "../../src/cli.ts"],
  "sourcesContent": ["import figlet from 'figlet';\nimport pkg from '../package.json';\nimport { SSVScannerCommand } from './commands/SSVScannerCommand';\n\nconst FigletMessage = async (message: string) => {\n  return new Promise(resolve => {\n    figlet(message, (error: any, output?: string) => {\n      if (error) {\n        return resolve('');\n      }\n      resolve(output);\n    });\n  })\n}\n\nexport default async function main(): Promise<any> {\n  const messageText = `SSV Scanner v${pkg.version}`;\n  const message = await FigletMessage(messageText);\n  if (message) {\n    console.log(' ----------------------------------------------------------------------');\n    console.log(`${message || messageText}`);\n    console.log(' ----------------------------------------------------------------------');\n    for (const str of String(pkg.description).match(/.{1,67}/g) || []) {\n      console.log(` ${str}`);\n    }\n    console.log(' ----------------------------------------------------------------------\\n');\n  }\n\n  try {\n    const command = new SSVScannerCommand();\n    console.debug(await command.execute());\n  } catch (e: any) {\n    console.error('\\x1b[31m', e.message);\n  }\n}\n", "import { ArgumentParser } from 'argparse';\n\nimport Web3Provider from '../lib/web3.provider';\n\nexport class SSVScannerCommand {\n  protected DAY = 5400;\n  protected WEEK = this.DAY * 7;\n  protected MONTH = this.DAY * 30;\n\n  protected eventsList = [\n    'ClusterDeposit',\n    'ClusterWithdrawn',\n    'ValidatorRemoved',\n    'ValidatorAdded',\n    'ClusterLiquidated',\n    'ClusterReactivated',\n  ]\n\n  private params: any;\n\n  constructor() {\n    const parser = new ArgumentParser();\n\n    parser.add_argument('-n', '--node-url', {\n      help: `The ETH1 node url.`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-ca', '--ssv-contract-address', {\n      help:\n        'The SSV Contract address, used to find the latest cluster data snapshot. ' +\n        'Refer to https://docs.ssv.network/developers/smart-contracts',\n      required: true,\n      dest: 'contractAddress'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The liquidator's recipient address private key, used for creating a liquidation transaction\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n    parser.add_argument('-oids', '--operator-ids', {\n      help: `Comma-separated list of operators IDs from the contract in the same sequence as you provided operators itself`,\n      required: true,\n      dest: 'operatorIds'\n    });\n\n    this.params = parser.parse_args();\n    this.params.operatorIds = this.params.operatorIds.split(',')\n      .map((value: any) => {\n        if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n        return +value;\n      });\n    // this.subParserOptions.help += 'Example: \"ssv-scanner key-shares --help\" or \"ssv-keys ksh --help\"'\n  }\n\n  async execute(): Promise<any> {\n    const cluster = await this.getClusterSnapshot(this.MONTH, await Web3Provider.web3(this.params.nodeUrl).eth.getBlockNumber());\n\n    return {\n      params: { ...this.params },\n      cluster: JSON.stringify(cluster),\n    };\n  }\n\n  async getClusterSnapshot(range: any, toBlock: any): Promise<any> {\n    const filters = {\n      fromBlock: toBlock - range,\n      toBlock,\n      filter: {\n        owner: this.params.ownerAddress,\n      }\n    };\n\n    let result = [];\n    try {\n      // console.log(\"???\", filters.fromBlock, filters.toBlock);\n      if (filters.fromBlock <= 0) return null;\n      result = await Web3Provider.contract(this.params.nodeUrl, this.params.contractAddress).getPastEvents('allEvents', filters);\n    } catch(e) {\n      console.error(e);\n      let step;\n      if (range === this.MONTH) {\n        step = this.WEEK;\n      } else if (range === this.WEEK) {\n        step = this.DAY;\n      }\n      result = await this.getClusterSnapshot(step, toBlock);\n    }\n    let clusterSnapshot: any = null;\n    let biggestBlockNumber = 0;\n    result\n      .filter((item: any) => this.eventsList.includes(item.event))\n      .filter((item: any) => JSON.stringify(item.returnValues.operatorIds.map((value: any) => +value)) === JSON.stringify(this.params.operatorIds))\n      .forEach((item: any) => {\n        if (item.blockNumber > biggestBlockNumber) {\n          biggestBlockNumber = item.blockNumber;\n          clusterSnapshot = item.returnValues.cluster;\n        }\n      });\n\n    if (!clusterSnapshot) {\n      return await this.getClusterSnapshot(this.MONTH, toBlock - range);\n    }\n\n    return clusterSnapshot;\n  }\n}\n", "import Web3 from 'web3';\nimport ABI_V3 from '../shared/v3.abi.json';\n\nexport default class Web3Provider {\n  static BLOCK_RANGE_500K = 500000;\n\n  static web3(nodeUrl: string) {\n    return new Web3(nodeUrl);\n  }\n\n  static get abi() {\n    return ABI_V3 as any;\n  }\n\n  static contract(nodeUrl: string, contractAddress: string) {\n    return new (Web3Provider.web3(nodeUrl)).eth.Contract(\n      Web3Provider.abi,\n      contractAddress,\n    );\n  }\n\n  /*\n  static async currentBlockNumber(): Promise<number> {\n    return await Web3Provider.web3.eth.getBlockNumber();\n  }\n\n  static async liquidationThresholdPeriod(): Promise<number> {\n    return Web3Provider.contract.methods.getLiquidationThresholdPeriod().call();\n  }\n\n  static async minimumBlocksBeforeLiquidation(): Promise<number> {\n    return Web3Provider.contract.methods.getLiquidationThresholdPeriod().call();\n  }\n\n  static async liquidatable(ownerAddress): Promise<boolean> {\n    return Web3Provider.contract.methods.isLiquidatable(ownerAddress).call();\n  }\n\n  static async isLiquidated(ownerAddress): Promise<boolean> {\n    return Web3Provider.contract.methods\n      .isOwnerValidatorsDisabled(ownerAddress)\n      .call();\n  }\n\n  static async burnRate(ownerAddress): Promise<string> {\n    return Web3Provider.contract.methods\n      .getAddressBurnRate(ownerAddress)\n      .call();\n  }\n\n  static async totalBalanceOf(ownerAddress): Promise<string> {\n    return Web3Provider.contract.methods.getAddressBalance(ownerAddress).call();\n  }\n  */\n}\n", "#!/usr/bin/env node\n'use strict';\nimport main from './cli-shared';\n\nvoid main();\n"],
  "mappings": "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",
  "names": ["import_figlet", "import_argparse", "import_web3", "_Web3Provider", "nodeUrl", "Web3", "v3_abi_default", "contractAddress", "Web3Provider", "SSVScannerCommand", "parser", "value", "__async", "cluster", "Web3Provider", "__spreadValues", "range", "toBlock", "filters", "result", "e", "step", "clusterSnapshot", "biggestBlockNumber", "item", "FigletMessage", "message", "__async", "resolve", "figlet", "error", "output", "main", "messageText", "package_default", "str", "command", "SSVScannerCommand", "e", "main"]
}
